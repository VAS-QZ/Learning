# Java内存区域

在我们的日常编程中，常常会有这样的疑问

- new的对象究竟储存在哪里呢？

- 对象究竟是根据哪里的模板生成的呢？

- 为什么我进入一个方法并执行完毕之后还能返回我进入的位置呢？

  ......

那么本文就来从Java内存区域的角度来说一说这些问题

[TOC]

## 内存区域介绍

![1557325334502](./pic/内存区域.png)

如上图所示，Java的运行时区域分为如上5个部分

1. Heap：Java堆。用于存放对象实例和数组，分为年轻代和老年代，年轻代又可分为survior区和Eden区

2. 虚拟机栈：最小单元为栈帧，每个方法的开始和完成就对应着一个栈帧的入栈与出栈操作，每个虚拟机栈都是线程独立的。在栈顶的栈帧被称为当前栈帧，当前线程只处理当前栈帧。在虚拟机栈中保存了动态链接、操作数栈、局部变量表、返回地址等信息。

   > - 动态链接：符号引用在编辑阶段就转为直接引用的称为静态连接，在程序运行时解析为直接引用的程为动态链接
   >
   > - 操作数栈：存放操作数
   >
   >   > 一条add指令需要两个操作数，这两个操作数就会放在操作数栈中，当执行add时进行出栈相加操作
   >
   > - 局部变量表：存储方法参数信息以及方法中定义的局部变量
   >
   > - 返回地址：正常返回时取PC计数器中的地址，异常返回则由异常处理器处理

3. 本地方法栈：native方法所使用的栈

4. 程序计数器：记录当前线程执行到了哪里，线程独立

5. 方法区：存储每个类的结构如运行时常量池，属性和方法数据

除此之外还有两部分区域是我们需要关注的

1. 运行时常量池：运行时常量池属于方法区的一部分，在《Java虚拟机规范》中对这部分的定义是这样的

   > A *run-time constant pool* is a per-class or per-interface run-time representation of the `constant_pool` table in a `class` file

   也就是说运行时常量池是每个类或接口的class文件中的常量池的运行时体现

2. 直接内存：直接内存并不属于运行时区域，但是在开发过程中我们确实可以用到，使用直接内存进行IO将会拥有比使用堆内存进行IO更高的效率，这是由于其数据流的流转不同而造就的

   ```mermaid
   graph LR
   	subgraph 直接内存
   	A(本地IO)-->B(直接内存)
   	B-->C(本地IO)
   	end
   	subgraph 堆内存
   	D(本地IO)--切换到内核态-->E(内核缓存)
   	E--复制-->F(堆内存)
   	F-->H(本地IO)
   	end
   ```

   > 上图解释
   >
   > - 传统文件IO时，Java进程又用户态切换为内核态，而后从内核缓存中将数据拷贝到堆内存中
   > - 使用直接内存时，直接内存可以直接映射到需要操作的文件。

   ::: tip

   虽然直接内存的操作比传统IO要快，是直接内存的申请却慢于堆内存的申请

   :::

## 池技术



## Q&A

运行时常量池中存放的时字面量和符号引用，字符串常量池中存放的是字符串，这二者有什么关系？

元空间和直接内存都使用的是本地内存，二者有什么关系吗？

jdk6中的方法区所存储的东西在jdk7和jdk8分别做了哪些转移？

## 结论

常量池在方法区中

字符串常量池和常量池是两个东西，没有关系