# 类加载机制

[TOC]

一个类时如何被虚拟机加载运行？究竟经历了哪些步骤呢？本文就Java中类的加载机制进行详细的讲解。

## 加载过程

一个类从被虚拟机加载直到被虚拟机卸载的过程程为类的生命周期，可分为以下7个步骤

```mermaid
graph LR
	a(加载)-->b(验证)
	subgraph 连接
	b-->c(准备)
	c-->d(解析)
	end
	d-->e(初始化)
	e-->f(使用)
	f-->g(卸载)
```

每个类都会经历以上7个步骤，其中加载、验证、准备、初始化、卸载这五个步骤将按部就班的**开始**，而解析则不一定，解析可能会在初始化之后才开始进行

### 加载

加载阶段的工作，就是获取类的二进制流，并将其放入虚拟机中

1. 类加载器根据类的全限定名获取类的二进制流
2. 根据二进制流所代表的数据结构在方法区生成对应的数据结构
3. 根据数据结构在方法区生成java.lang.Class对象作为该类的入口

类的加载阶段是程序员们可操作性最大的阶段、我们可以使用虚拟机自带的类加载器，也可以自定义类加载器

### 验证

由于二进制流的获取途径后很多，可以通过Java文件、网络、直接使用二进制编辑器编写、数据库、JSP，所以就需要对加载进来的class进行验证，主要验证一下4个方面

1. 文件格式验证
2. 元数据验证（Java语法验证）
3. 字节码验证（自卫验证，防止有对虚拟机有害的代码）
4. 符号引用验证（是否每个符号引用都可以找到对应的类）

验证阶段和加载阶段有一部分时交叉进行的，而且如果验证程序是没有问题的话在实施阶段可以通过*-Xverify:none*来关闭

### 准备

再通过验证之后，虚拟机就要对所有的**类成员变量**进行内存分配，此时并不对实例对象进行内存分配。这个时候的类成员变量还是其零值，类成员变量的零值如下表

| char   | 0    | int       | 0    |
| ------ | ---- | --------- | ---- |
| long   | 0    | short     | 0    |
| String | “”   | reference | null |
| float  | 0    | double    | 0    |

但是对于已经被final修饰过的类成员变量，在准备阶段就已经赋为了实际值

### 解析

解析阶段的工作就是将符号引用转化为直接引用

> **符号引用**：可以是任意的形式指定到类
>
> **直接引用**：必须指定到类

每个类可能被多次解析，解析结果在虚拟机中有缓存保留，第一次解析成功后，接下来的解析也应保证其解析成功

### 初始化

在初始化阶段，虚拟机为每一个类收集并生成\<clint>方法，每个\<clint>方法由static静态代码块和静态赋值语句生成，如果一个类中没有上述代码则不生成\<clint>方法。其收集顺序取决于在代码中的顺序，static静态代码块可以修改在其之后的静态变量，但是却不能访问。每个类的\<clint>方法执行之前其父类一定已经初始化，所以第一个初始化的类一定是Object。接口则不需要，虚拟机可以保证\<clint>方法的线程安全，所以单例模式的饿汉式是线程安全的

当且仅当类在以下五种情况下会进行初始化

1. 当遇到new、putstatic、getstatic、invoke指令时
2. main方法所在类
3. 当一个类被初始化时，其父类一定已经完成了初始化
4. 当使用java.lang.invoke时
5. 当使用java.util.methodHandle时

以上五种情况称为对类的主动引用，当然还有几种对类的被动引用

- 通过子类来引用父类中的类变量
- 