# 享元模式

享元模式的英文原名为Flyweight Pattern，又可以称之为蝇量模式。不够这里使用享元模式对其进行命名更可以反映模式的用意：享元，共享元数据。享元模式以**共享**的方式高效的支持**细颗粒**的对象。

### 场景假设

现在我们模拟围棋对弈的场景，对弈双方每次下一个棋子，如果二人棋力相当，那么将有可能会出现棋盘被下满的场景

那面对这样的场景我们应该如何做呢？首先新建一个棋子类，用来保存棋子的颜色和位置，示例代码如下

```Java
@Getter
@Setter
@AllArgsConstructor
public class Chess implements Chess {

    private String color;

    private String X;

    private String Y;
}
```

于是我们在下棋的时候每当对弈双方下一个子时，我们就需要new一个棋子出来，如果双方把棋局下满的话，那我们就需要new几百个棋子出来，这无疑使造成了内存的浪费，于是我们对上述场景进行分析后，发现了以下几个特点

1. 棋子只有黑白两种颜色，同样颜色的棋子本身并无不同
2. 棋子本身并不需要知道自己的坐标

以上就是我们的场景假设，接下来我们来尝试使用享元模式来解决这个问题

### 模式介绍

#### 概念引入

在具体介绍享元模式之前，我们首先来介绍两个概念

- 内部状态：储存在享元对象内部，不会随着外界的影响而改变的状态，内部状态可以共享
- 外部状态：会随着外界的影响而改变的状态，享元对象不对其进行保存，外部状态的保存应该由客户端负责

#### 类图

![](./pic/flyweight.jpg)

在享元模式中，有四个角色

- 抽象享元类：享元类的父类
- 具体享元类：共享的享元类
- 不共享具体享元类：不共享的享元类
- 享元工厂：生产具体享元类，并保存已生产的享元类

以上就是享元模式的概念介绍，接下来我们用享元模式来解决场景假设中的两个问题

首先我们对棋子类进行属性的分类。很明显，颜色是棋子的内部状态，棋子的颜色不随着外界的影响而改变。棋子的坐标属于外部状态，会随着对弈双方的选择而不同。于是我们对棋子类进行了更改

```java
@Getter
@Setter
@AllArgsConstructor
public class ConcreteChess implements Chess {

    private String color;

    public void show(String x, String y) {
        System.out.println(this.color + " X:" + x + "Y:" + y);
    }
}
```

同时增加了一个棋子的工厂类，工厂类中保存已创建的棋子

```Java
public class ChessFactory {

    private Map<String, Chess> chessPool = new HashMap<>();

    public Chess getChess(String color) {
        Chess res = chessPool.get(color);
        if(res == null) {
            res = new ConcreteChess(color);
            chessPool.put(color, res);
            return res;
        }
        return res;
    }
}
```

于是当我们使用享元模式优化过的代码时，就不会再造成内存的浪费了。

### 已有的优秀享元模式的应用

#### 字符串常量池

#### 数据库连接池

#### 线程池