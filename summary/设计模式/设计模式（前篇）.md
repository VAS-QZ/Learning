# 设计模式（前篇）

为了更好的理解设计模式，首先需要明确的了解两个知识点

## 类图中类与类之间的关系

- 泛化：继承，java关键字：**extends**
- 实现：实现，java关键字：**implement**
- 依赖：A类使用到了B类，非必然性，java翻译：**A的某一个方法中使用到了B，B是A类中的某一个临时变量**
- 关联：A类使用到了B类，必然性，java翻译：**A的某一个私有域为B**，朋友
- 聚合：A类使用到了B类，A与B具有**整体个体**关系，**B可以独立于A存在**，人之于人群
- 组合：A类使用到了B类，A与B具有**整体个体**关系，**B不可以独立于A存在**，胳膊之于人

## 类的设计原则

- **单一职责原则（SRP）**
  - 一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因
  - [示例](https://blog.csdn.net/lovelion/article/details/7536542)
- **开闭原则（OCP）**
  - 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展
  - 抽象化是开闭原则的关键
  - [示例](https://blog.csdn.net/lovelion/article/details/7537584)
- **里氏代换原则**（LSP）
  - 所有引用基类（父类）的地方必须能透明地使用其子类的对象。
- **依赖倒置原则（DIP）**
  - 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程
- **接口隔离原则**
  - 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。
- **迪米特原则（LOD）/最少知识原则（LKP）**
  - 一个软件实体应当尽可能少地与其他实体发生相互作用

在了解了以上两个知识点之后，在接下来设计模式的学习中就会变得游刃有余

## 设计模式分类

如设计模式参考书中提到的，一共有23种设计模式，这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）

- **创建性设计模式**
  - 工厂模式（Factory Pattern）
  - 抽象工厂模式（Abstract Factory Pattern）
  - 单例模式（Singleton Pattern）
  - 建造者模式（Builder Pattern）
  - 原型模式（Prototype Pattern）
- **结构型模式**
  - 适配器模式（Adapter Pattern）
  - 桥接模式（Bridge Pattern）
  - 过滤器模式（Filter、Criteria Pattern）
  - 组合模式（Composite Pattern）
  - 装饰器模式（Decorator Pattern）
  - 外观模式（Facade Pattern）
  - 享元模式（Flyweight Pattern）
  - 代理模式（Proxy Pattern）
- **行为型设计模式**
  - 责任链模式（Chain of Responsibility Pattern）
  - 命令模式（Command Pattern）
  - 解释器模式（Interpreter Pattern）
  - 迭代器模式（Iterator Pattern）
  - 中介者模式（Mediator Pattern）
  - 备忘录模式（Memento Pattern）
  - 观察者模式（Observer Pattern）
  - 状态模式（State Pattern）
  - 空对象模式（Null Object Pattern）
  - 策略模式（Strategy Pattern）
  - 模板模式（Template Pattern）
  - 访问者模式（Visitor Pattern）



