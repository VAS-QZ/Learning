# 设计模式（前篇）

为了更好的理解设计模式，首先需要明确的了解两个知识点

## 类与类之间的关系

- 泛化：继承
  - java关键字：**extends**
- 实现：实现
  - java关键字：**implement**
- 依赖：A类使用到了B类，非必然性
  - java翻译：**A的某一个方法中使用到了B，B是A类中的某一个临时变量**
- 关联：A类使用到了B类，必然性
  - java翻译：A的某一个私有域为B
  - 类比：朋友关系
- 聚合：A类使用到了B类，A与B具有**整体个体**关系，**B可以独立于A存在**
  - java翻译：A的某一个私有域为B
  - 类比：人之于人群
- 组合：A类使用到了B类，A与B具有**整体个体**关系，**B不可以独立于A存在**
  - java翻译：A的某一个私有域为B
  - 类比胳膊之于人

## 类的设计原则

- **单一职责原则（SRP）**
  - 概念：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因
  - [示例](https://blog.csdn.net/lovelion/article/details/7536542)
- **开闭原则（OCP）**
  - 概念：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展
  - 关键：抽象化
  - [示例](https://blog.csdn.net/lovelion/article/details/7537584)
- **里氏代换原则**（LSP）
  - 概念：所有引用基类（父类）的地方必须能透明地使用其子类的对象。
  - 里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此**在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象**。
  - [示例](https://blog.csdn.net/LoveLion/article/details/7540445)
- **依赖倒置原则（DIP）**
  - 概念：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程
  -  依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情
  - [示例](https://blog.csdn.net/LoveLion/article/details/7562783)
- **接口隔离原则（ISP）**
  - 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。
  -  在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便
  - [示例](https://blog.csdn.net/LoveLion/article/details/7562842)
- **迪米特原则（LOD）/最少知识原则（LKP）**
  - 一个软件实体应当尽可能少地与其他实体发生相互作用
  - 不要和“陌生人”说话、只与你的直接朋友通信，朋友如下
    - 当前对象本身(this)
    - 以参数形式传入到当前对象方法中的对象
    - 当前对象的成员对象
    - 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友
    - 当前对象所创建的对象
  - [示例](https://blog.csdn.net/LoveLion/article/details/7562783)

- **组合/聚合复用原则（CARP）**
  - 尽量使用对象组合，而不是继承来达到复用的目的。
  - [示例](https://blog.csdn.net/LoveLion/article/details/7563441)

::: TIP

一般地，可以把这七个原则分成了以下两个部分：

**设计目标**：开闭原则、里氏代换原则、迪米特原则
**设计方法**：单一职责原则、接口分隔原则、依赖倒置原则、组合/聚合复用原则

::: 

**在了解了以上两个知识点之后，在接下来设计模式的学习中就会变得游刃有余**

上述示例皆来自于[Liuwei-Sunny](https://me.csdn.net/LoveLion)

## 设计模式分类

如设计模式参考书中提到的，一共有23种设计模式，这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）

- **创建性设计模式**
  - 工厂模式（Factory Pattern）
  - 抽象工厂模式（Abstract Factory Pattern）
  - 单例模式（Singleton Pattern）
  - 建造者模式（Builder Pattern）
  - 原型模式（Prototype Pattern）
- **结构型模式**
  - 适配器模式（Adapter Pattern）
  - 桥接模式（Bridge Pattern）
  - 过滤器模式（Filter、Criteria Pattern）
  - 组合模式（Composite Pattern）
  - 装饰器模式（Decorator Pattern）
  - 外观模式（Facade Pattern）
  - 享元模式（Flyweight Pattern）
  - 代理模式（Proxy Pattern）
- **行为型设计模式**
  - 责任链模式（Chain of Responsibility Pattern）
  - 命令模式（Command Pattern）
  - 解释器模式（Interpreter Pattern）
  - 迭代器模式（Iterator Pattern）
  - 中介者模式（Mediator Pattern）
  - 备忘录模式（Memento Pattern）
  - 观察者模式（Observer Pattern）
  - 状态模式（State Pattern）
  - 空对象模式（Null Object Pattern）
  - 策略模式（Strategy Pattern）
  - 模板模式（Template Pattern）
  - 访问者模式（Visitor Pattern）



