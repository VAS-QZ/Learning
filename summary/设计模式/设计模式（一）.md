# 设计模式（一）

## 创建型设计模式

这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

### 单例模式

- 使用场景：一个类只存在一个实例
- 分类
  - 懒汉式
    - 只判空
    - 同步方法
    - 同步代码块
    - 同步代码块双重检查
    - 静态内部类
    - 枚举类
  - 饿汉式
    - 静态常量
    - 静态代码块

### 工厂模式

- 使用场景：创建有共性的多种实例，需要隐藏其创建逻辑

- 角色

  - 共性接口
  - 共性接口实现类
  - 工厂

- UML图

  ![1552729946490](.\pic\factory.png)

有图可见，Block和Circle实现了Shape接口，由工厂ShapeFactory来创建shape类

- 是否符合6大法则

  |          | 单一指责 | 开闭                                  | 里氏 | 依赖倒置 | 迪米特 | 接口隔离 |
  | -------- | -------- | ------------------------------------- | ---- | -------- | ------ | -------- |
  | 是否符合 | √        | ×                                     | √    | √        | √      | √        |
  | 解释     |          | 增加一个Shape实现类时需要修改工厂代码 |      |          |        |          |

  

### 抽象工厂模式

要理解抽象工厂模式就需要先理解产品族的概念，先来看看度娘对产品族的解释

> 产品族：产品族是以产品平台为基础，通过添加不同的个性模块，以满足不同客户个性化需求的一组相关产品。

- 使用场景：产品相对复杂，拥有产品族的概念
- 角色
  - 抽象接口
  - 抽象接口实现类
  - 抽象工厂
  - 抽象工厂实现类
- 类图

### 建造者模式

- 建造者模式和抽象工厂模式的区别

  > 抽象模式关注的是一个个零件的具体建造，不关心这些零件是干什么的
  >
  > 建造者模式关注的是产品如何由零件构成，不关心这些零件如何生产

- 角色

  - 产品类
  - 抽象建造者
  - 具体建造者
  - 指挥官

- 类图

### 原型模式

实现Cloneable接口